{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\jborn\\\\Documents\\\\GitHub\\\\NFT-pixelVizslas\\\\candy-machine-ui\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\jborn\\\\Documents\\\\GitHub\\\\NFT-pixelVizslas\\\\candy-machine-ui\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = require(\"react\");\n\nvar types_1 = require(\"../types\");\n\nvar logger_1 = __importDefault(require(\"../logger\"));\n\nvar useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\n\nvar usePowo = function usePowo(_ref, state, dispatch) {\n  var wallet = _ref.wallet,\n      chainImplementation = _ref.chainImplementation;\n  var powoFinished = state.powoFinished,\n      walletPowoInProgress = state.walletPowoInProgress,\n      refreshInProgress = state.refreshInProgress,\n      ownerTransactionConfirmed = state.ownerTransactionConfirmed;\n\n  var _ref2 = (0, useWalletHooks_1.default)(wallet, state, dispatch),\n      expectWalletConnected = _ref2.expectWalletConnected;\n  /**\n   * wait until the user has confirmed they want to continue the proof of wallet ownership flow\n   * then resolve the promise\n   */\n\n\n  var waitForConfirmPOWO = (0, react_1.useCallback)(\n  /*#__PURE__*/\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(payload) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              logger_1.default.debug('usePowo waitForConfirmPOWO before expectWalletConnected', {\n                payload: payload\n              });\n              expectWalletConnected();\n              return _context.abrupt(\"return\", new Promise(function (resolve) {\n                logger_1.default.debug('usePowo waitForConfirmPOWO', {\n                  powoFinished: powoFinished\n                });\n\n                if (powoFinished) {\n                  resolve(payload);\n                }\n              }));\n\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref3.apply(this, arguments);\n    };\n  }(), [powoFinished, expectWalletConnected]);\n  /**\n   * wait until the user has provided proof of wallet ownership using their connected wallet\n   * if this was triggered from the refresh flow, dispatch events to indicate progress\n   * if not, resolve a promise when the proof is ready\n   */\n\n  var waitForPOWO = (0, react_1.useCallback)( /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2( // eslint-disable-next-line @typescript-eslint/no-shadow\n    payload) {\n      var connectedWallet;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              logger_1.default.debug('usePowo waitForPOWO before expectWalletConnected');\n              connectedWallet = expectWalletConnected();\n\n              if (!connectedWallet) {\n                _context2.next = 5;\n                break;\n              }\n\n              logger_1.default.debug('usePowo waitForPOWO', {\n                payload: payload,\n                publicKey: connectedWallet.publicKey\n              });\n              return _context2.abrupt(\"return\", new Promise(function (resolve) {\n                logger_1.default.debug('usePowo waitForPOWO walletPowoInProgress', {\n                  walletPowoInProgress: walletPowoInProgress,\n                  refreshInProgress: refreshInProgress\n                });\n                chainImplementation.proveWalletOwnership().then(function (proof) {\n                  resolve({\n                    proof: proof,\n                    payload: payload\n                  });\n                  dispatch({\n                    type: 'walletPowoComplete'\n                  });\n                  dispatch({\n                    type: 'civicPass_check_token_status'\n                  });\n                }).catch(function (error) {\n                  logger_1.default.error('Proof of wallet ownership error: ', error);\n                  dispatch({\n                    type: 'walletPowoIncomplete'\n                  });\n                });\n              }));\n\n            case 5:\n              return _context2.abrupt(\"return\", {});\n\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x2) {\n      return _ref4.apply(this, arguments);\n    };\n  }(), [expectWalletConnected, walletPowoInProgress, chainImplementation]);\n  /**\n   * wait until the user has confirmed they want to continue the sign transaction flow\n   * then resolve the promise\n   */\n\n  var waitForTransactionConfirm = (0, react_1.useCallback)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            expectWalletConnected();\n            return _context3.abrupt(\"return\", new Promise(function (resolve) {\n              logger_1.default.debug('usePowo waitForTransactionConfirm', {\n                ownerTransactionConfirmed: ownerTransactionConfirmed\n              });\n\n              if (ownerTransactionConfirmed) {\n                resolve();\n              }\n            }));\n\n          case 2:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  })), [ownerTransactionConfirmed, expectWalletConnected]);\n  /**\n   * wait for the user sign transaction callback and then dispatch awaiting owner transaction\n   * to set the correct status while waiting for the token on chain\n   */\n\n  var waitForHandleTransaction = (0, react_1.useCallback)( /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(transaction) {\n      var errorMessage, errorCode, payload;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              logger_1.default.debug('waitForHandleTransaction', transaction);\n              _context4.prev = 1;\n              _context4.next = 4;\n              return chainImplementation.handleUserSignedTransaction(transaction);\n\n            case 4:\n              dispatch({\n                type: 'walletPowoComplete'\n              });\n              _context4.next = 16;\n              break;\n\n            case 7:\n              _context4.prev = 7;\n              _context4.t0 = _context4[\"catch\"](1);\n              errorMessage = _context4.t0 && _context4.t0 instanceof Error ? _context4.t0.message : 'ChainTransaction error';\n              errorCode = _context4.t0 === null || _context4.t0 === void 0 ? void 0 : _context4.t0.errorCode;\n              logger_1.default.error('waitForHandleTransaction error', {\n                errorCode: errorCode\n              });\n              payload = Object.assign({}, errorCode ? {\n                errorCode: errorCode\n              } : {});\n              logger_1.default.error('waitForHandleTransaction (error instanceof ChainError)', errorCode);\n              dispatch({\n                type: 'civicPass_owner_sends_chainTransactionError',\n                payload: payload\n              });\n              throw new types_1.ChainTransactionError(errorMessage);\n\n            case 16:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, null, [[1, 7]]);\n    }));\n\n    return function (_x3) {\n      return _ref6.apply(this, arguments);\n    };\n  }(), [chainImplementation]);\n  return {\n    waitForConfirmPOWO: waitForConfirmPOWO,\n    waitForTransactionConfirm: waitForTransactionConfirm,\n    waitForHandleTransaction: waitForHandleTransaction,\n    waitForPOWO: waitForPOWO\n  };\n};\n\nexports.default = usePowo;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","react_1","require","types_1","logger_1","useWalletHooks_1","usePowo","state","dispatch","wallet","chainImplementation","powoFinished","walletPowoInProgress","refreshInProgress","ownerTransactionConfirmed","default","expectWalletConnected","waitForConfirmPOWO","useCallback","payload","debug","Promise","resolve","waitForPOWO","connectedWallet","publicKey","proveWalletOwnership","then","proof","type","catch","error","waitForTransactionConfirm","waitForHandleTransaction","transaction","handleUserSignedTransaction","errorMessage","Error","message","errorCode","assign","ChainTransactionError"],"sources":["C:/Users/jborn/Documents/GitHub/NFT-pixelVizslas/candy-machine-ui/node_modules/@civic/common-gateway-react/dist/esm/useHooks/usePOWO.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst react_1 = require(\"react\");\nconst types_1 = require(\"../types\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\nconst usePowo = ({ wallet, chainImplementation }, state, dispatch) => {\n    const { powoFinished, walletPowoInProgress, refreshInProgress, ownerTransactionConfirmed } = state;\n    const { expectWalletConnected } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n    /**\n     * wait until the user has confirmed they want to continue the proof of wallet ownership flow\n     * then resolve the promise\n     */\n    const waitForConfirmPOWO = (0, react_1.useCallback)(\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    async (payload) => {\n        logger_1.default.debug('usePowo waitForConfirmPOWO before expectWalletConnected', {\n            payload,\n        });\n        expectWalletConnected();\n        return new Promise((resolve) => {\n            logger_1.default.debug('usePowo waitForConfirmPOWO', { powoFinished });\n            if (powoFinished) {\n                resolve(payload);\n            }\n        });\n    }, [powoFinished, expectWalletConnected]);\n    /**\n     * wait until the user has provided proof of wallet ownership using their connected wallet\n     * if this was triggered from the refresh flow, dispatch events to indicate progress\n     * if not, resolve a promise when the proof is ready\n     */\n    const waitForPOWO = (0, react_1.useCallback)(async (\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    payload) => {\n        logger_1.default.debug('usePowo waitForPOWO before expectWalletConnected');\n        const connectedWallet = expectWalletConnected();\n        if (connectedWallet) {\n            logger_1.default.debug('usePowo waitForPOWO', {\n                payload,\n                publicKey: connectedWallet.publicKey,\n            });\n            return new Promise((resolve) => {\n                logger_1.default.debug('usePowo waitForPOWO walletPowoInProgress', {\n                    walletPowoInProgress,\n                    refreshInProgress,\n                });\n                chainImplementation\n                    .proveWalletOwnership()\n                    .then((proof) => {\n                    resolve({ proof, payload });\n                    dispatch({ type: 'walletPowoComplete' });\n                    dispatch({ type: 'civicPass_check_token_status' });\n                })\n                    .catch((error) => {\n                    logger_1.default.error('Proof of wallet ownership error: ', error);\n                    dispatch({ type: 'walletPowoIncomplete' });\n                });\n            });\n        }\n        return {};\n    }, [expectWalletConnected, walletPowoInProgress, chainImplementation]);\n    /**\n     * wait until the user has confirmed they want to continue the sign transaction flow\n     * then resolve the promise\n     */\n    const waitForTransactionConfirm = (0, react_1.useCallback)(async () => {\n        expectWalletConnected();\n        return new Promise((resolve) => {\n            logger_1.default.debug('usePowo waitForTransactionConfirm', { ownerTransactionConfirmed });\n            if (ownerTransactionConfirmed) {\n                resolve();\n            }\n        });\n    }, [ownerTransactionConfirmed, expectWalletConnected]);\n    /**\n     * wait for the user sign transaction callback and then dispatch awaiting owner transaction\n     * to set the correct status while waiting for the token on chain\n     */\n    const waitForHandleTransaction = (0, react_1.useCallback)(async (transaction) => {\n        logger_1.default.debug('waitForHandleTransaction', transaction);\n        try {\n            await chainImplementation.handleUserSignedTransaction(transaction);\n            dispatch({ type: 'walletPowoComplete' });\n        }\n        catch (error) {\n            const errorMessage = error && error instanceof Error ? error.message : 'ChainTransaction error';\n            const errorCode = error === null || error === void 0 ? void 0 : error.errorCode;\n            logger_1.default.error('waitForHandleTransaction error', { errorCode });\n            const payload = Object.assign({}, (errorCode ? { errorCode } : {}));\n            logger_1.default.error('waitForHandleTransaction (error instanceof ChainError)', errorCode);\n            dispatch({ type: 'civicPass_owner_sends_chainTransactionError', payload });\n            throw new types_1.ChainTransactionError(errorMessage);\n        }\n    }, [chainImplementation]);\n    return {\n        waitForConfirmPOWO,\n        waitForTransactionConfirm,\n        waitForHandleTransaction,\n        waitForPOWO,\n    };\n};\nexports.default = usePowo;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}