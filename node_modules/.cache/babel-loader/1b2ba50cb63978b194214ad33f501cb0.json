{"ast":null,"code":"/* eslint-disable */\nimport { Transaction } from \"@solana/web3.js\";\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\nexport const DEFAULT_TIMEOUT = 60000;\nexport const getErrorForTransaction = async (connection, txid) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, \"max\");\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n  const errors = [];\n\n  if (tx !== null && tx !== void 0 && tx.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\nexport let SequenceType;\n\n(function (SequenceType) {\n  SequenceType[SequenceType[\"Sequential\"] = 0] = \"Sequential\";\n  SequenceType[SequenceType[\"Parallel\"] = 1] = \"Parallel\";\n  SequenceType[SequenceType[\"StopOnFailure\"] = 2] = \"StopOnFailure\";\n})(SequenceType || (SequenceType = {}));\n\nexport async function sendTransactionsWithManualRetry(connection, wallet, instructions, signers) {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength = null;\n  const toRemoveSigners = {};\n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let ids = [];\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        const id = await sendTransactionWithRetry(connection, wallet, instructions[0], filteredSigners[0], \"single\");\n        ids.push(id.txid);\n        stopPoint = 1;\n      } else {\n        const {\n          txs\n        } = await sendTransactions(connection, wallet, instructions, filteredSigners, SequenceType.StopOnFailure, \"single\");\n        ids = ids.concat(txs.map(t => t.txid));\n      }\n    } catch (e) {\n      console.error(e);\n    }\n\n    console.log(\"Died on \", stopPoint, \"retrying from instruction\", instructions[stopPoint], \"instructions length is\", instructions.length);\n    lastInstructionsLength = instructions.length;\n  }\n\n  return ids;\n}\nexport const sendTransactions = async function (connection, wallet, instructionSet, signersSet) {\n  let sequenceType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : SequenceType.Parallel;\n  let commitment = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"singleGossip\";\n  let successCallback = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : (txid, ind) => {};\n  let failCallback = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : (txid, ind) => false;\n  let block = arguments.length > 8 ? arguments[8] : undefined;\n  let beforeTransactions = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : [];\n  let afterTransactions = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : [];\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n  const unsignedTxns = beforeTransactions;\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    const transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  unsignedTxns.push(...afterTransactions);\n  const partiallySignedTransactions = unsignedTxns.filter(t => t.signatures.find(sig => sig.publicKey.equals(wallet.publicKey)));\n  const fullySignedTransactions = unsignedTxns.filter(t => !t.signatures.find(sig => sig.publicKey.equals(wallet.publicKey)));\n  let signedTxns = await wallet.signAllTransactions(partiallySignedTransactions);\n  signedTxns = fullySignedTransactions.concat(signedTxns);\n  const pendingTxns = [];\n  console.log(\"Signed txns length\", signedTxns.length, \"vs handed in length\", instructionSet.length);\n\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i]\n    });\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise.then(_ref => {\n          let {\n            txid,\n            slot\n          } = _ref;\n          return successCallback(txid, i);\n        });\n        pendingTxns.push(signedTxnPromise);\n      } catch (e) {\n        console.log(\"Failed at txn index:\", i);\n        console.log(\"Caught failure:\", e);\n        failCallback(signedTxns[i], i);\n\n        if (sequenceType === SequenceType.StopOnFailure) {\n          return {\n            number: i,\n            txs: await Promise.all(pendingTxns)\n          };\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    const result = await Promise.all(pendingTxns);\n    return {\n      number: signedTxns.length,\n      txs: result\n    };\n  }\n\n  return {\n    number: signedTxns.length,\n    txs: await Promise.all(pendingTxns)\n  };\n};\nexport const sendTransaction = async function (connection, wallet, instructions, signers) {\n  let awaitConfirmation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  let commitment = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"singleGossip\";\n  let includesFeePayer = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  let block = arguments.length > 7 ? arguments[7] : undefined;\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n  let transaction;\n\n  if (!Array.isArray(instructions)) {\n    transaction = instructions;\n  } else {\n    transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\n\n    if (includesFeePayer) {\n      transaction.setSigners(...signers.map(s => s.publicKey));\n    } else {\n      transaction.setSigners( // fee payed by the wallet owner\n      wallet.publicKey, ...signers.map(s => s.publicKey));\n    }\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    if (!includesFeePayer) {\n      transaction = await wallet.signTransaction(transaction);\n    }\n  }\n\n  const rawTransaction = transaction.serialize();\n  const options = {\n    skipPreflight: true,\n    commitment\n  };\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(txid, DEFAULT_TIMEOUT, connection, commitment);\n    if (!confirmation) throw new Error(\"Timed out awaiting confirmation on transaction\");\n    slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;\n\n    if (confirmation !== null && confirmation !== void 0 && confirmation.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n      console.log(errors);\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return {\n    txid,\n    slot\n  };\n};\nexport const sendTransactionWithRetry = async function (connection, wallet, instructions, signers) {\n  let commitment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"singleGossip\";\n  let includesFeePayer = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let block = arguments.length > 6 ? arguments[6] : undefined;\n  let beforeSend = arguments.length > 7 ? arguments[7] : undefined;\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const {\n    txid,\n    slot\n  } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction\n  });\n  return {\n    txid,\n    slot\n  };\n};\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\nexport async function sendSignedTransaction(_ref2) {\n  let {\n    signedTransaction,\n    connection,\n    timeout = DEFAULT_TIMEOUT\n  } = _ref2;\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid = await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight: true\n  });\n  console.log(\"Started awaiting confirmation for\", txid);\n  let done = false;\n\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true\n      });\n      await sleep(500);\n    }\n  })();\n\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(txid, timeout, connection, \"recent\", true);\n    if (!confirmation) throw new Error(\"Timed out awaiting confirmation on transaction\");\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error(\"Transaction failed: Custom instruction error\");\n    }\n\n    slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;\n  } catch (err) {\n    console.error(\"Timeout Error caught\", err);\n\n    if (err.timeout) {\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\n    }\n\n    let simulateResult = null;\n\n    try {\n      simulateResult = (await simulateTransaction(connection, signedTransaction, \"single\")).value;\n    } catch (e) {}\n\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n\n          if (line.startsWith(\"Program log: \")) {\n            throw new Error(\"Transaction failed: \" + line.slice(\"Program log: \".length));\n          }\n        }\n      }\n\n      throw new Error(JSON.stringify(simulateResult.err));\n    } // throw new Error('Transaction failed');\n\n  } finally {\n    done = true;\n  }\n\n  console.log(\"Latency\", txid, getUnixTs() - startTime);\n  return {\n    txid,\n    slot\n  };\n}\n\nasync function simulateTransaction(connection, transaction, commitment) {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash( // @ts-ignore\n  connection._disableBlockhashCaching);\n  const signData = transaction.serializeMessage(); // @ts-ignore\n\n  const wireTransaction = transaction._serialize(signData);\n\n  const encodedTransaction = wireTransaction.toString(\"base64\");\n  const config = {\n    encoding: \"base64\",\n    commitment\n  };\n  const args = [encodedTransaction, config]; // @ts-ignore\n\n  const res = await connection._rpcRequest(\"simulateTransaction\", args);\n\n  if (res.error) {\n    throw new Error(\"failed to simulate transaction: \" + res.error.message);\n  }\n\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(txid, timeout, connection) {\n  let commitment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"recent\";\n  let queryStatus = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let done = false;\n  let status = {\n    slot: 0,\n    confirmations: 0,\n    err: null\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n\n      done = true;\n      console.log(\"Rejecting for timeout...\");\n      reject({\n        timeout: true\n      });\n    }, timeout);\n\n    try {\n      subId = connection.onSignature(txid, (result, context) => {\n        done = true;\n        status = {\n          err: result.err,\n          slot: context.slot,\n          confirmations: 0\n        };\n\n        if (result.err) {\n          console.log(\"Rejected via websocket\", result.err);\n          reject(status);\n        } else {\n          console.log(\"Resolved via websocket\", result);\n          resolve(status);\n        }\n      }, commitment);\n    } catch (e) {\n      done = true;\n      console.error(\"WS error in setup\", txid, e);\n    }\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([txid]);\n          status = signatureStatuses && signatureStatuses.value[0];\n\n          if (!done) {\n            if (!status) {\n              console.log(\"REST null result for\", txid, status);\n            } else if (status.err) {\n              console.log(\"REST error for\", txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log(\"REST no confirmations for\", txid, status);\n            } else {\n              console.log(\"REST confirmation for\", txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log(\"REST connection error: txid\", txid, e);\n          }\n        }\n      })();\n\n      await sleep(2000);\n    }\n  }); //@ts-ignore\n\n  try {\n    await connection.removeSignatureListener(subId);\n  } catch (e) {// ignore\n  }\n\n  done = true;\n  console.log(\"Returning status\", status);\n  return status;\n}\n\nexport function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}","map":{"version":3,"names":["Transaction","WalletNotConnectedError","DEFAULT_TIMEOUT","getErrorForTransaction","connection","txid","confirmTransaction","tx","getParsedConfirmedTransaction","errors","meta","logMessages","forEach","log","regex","m","exec","index","lastIndex","length","push","SequenceType","sendTransactionsWithManualRetry","wallet","instructions","signers","stopPoint","tries","lastInstructionsLength","toRemoveSigners","filter","instr","i","ids","filteredSigners","_","slice","id","sendTransactionWithRetry","txs","sendTransactions","StopOnFailure","concat","map","t","e","console","error","instructionSet","signersSet","sequenceType","Parallel","commitment","successCallback","ind","failCallback","block","beforeTransactions","afterTransactions","publicKey","unsignedTxns","getRecentBlockhash","transaction","instruction","add","recentBlockhash","blockhash","setSigners","s","partialSign","partiallySignedTransactions","signatures","find","sig","equals","fullySignedTransactions","signedTxns","signAllTransactions","pendingTxns","signedTxnPromise","sendSignedTransaction","signedTransaction","then","slot","number","Promise","all","result","sendTransaction","awaitConfirmation","includesFeePayer","Array","isArray","signTransaction","rawTransaction","serialize","options","skipPreflight","sendRawTransaction","confirmation","awaitTransactionSignatureConfirmation","Error","err","beforeSend","getUnixTs","Date","getTime","timeout","startTime","done","sleep","simulateResult","simulateTransaction","value","logs","line","startsWith","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","config","encoding","args","res","_rpcRequest","message","queryStatus","status","confirmations","subId","resolve","reject","setTimeout","onSignature","context","signatureStatuses","getSignatureStatuses","removeSignatureListener","ms"],"sources":["C:/Users/jborn/Documents/GitHub/NFT-pixelVizslas/candy-machine-ui/src/connection.tsx"],"sourcesContent":["/* eslint-disable */\r\nimport {\r\n  Keypair,\r\n  Commitment,\r\n  Connection,\r\n  RpcResponseAndContext,\r\n  SignatureStatus,\r\n  SimulatedTransactionResponse,\r\n  Transaction,\r\n  TransactionInstruction,\r\n  TransactionSignature,\r\n  Blockhash,\r\n  FeeCalculator,\r\n} from \"@solana/web3.js\";\r\n\r\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\r\n\r\ninterface BlockhashAndFeeCalculator {\r\n  blockhash: Blockhash;\r\n  feeCalculator: FeeCalculator;\r\n}\r\n\r\nexport const DEFAULT_TIMEOUT = 60000;\r\n\r\nexport const getErrorForTransaction = async (\r\n  connection: Connection,\r\n  txid: string\r\n) => {\r\n  // wait for all confirmation before geting transaction\r\n  await connection.confirmTransaction(txid, \"max\");\r\n\r\n  const tx = await connection.getParsedConfirmedTransaction(txid);\r\n\r\n  const errors: string[] = [];\r\n  if (tx?.meta && tx.meta.logMessages) {\r\n    tx.meta.logMessages.forEach((log) => {\r\n      const regex = /Error: (.*)/gm;\r\n      let m;\r\n      while ((m = regex.exec(log)) !== null) {\r\n        // This is necessary to avoid infinite loops with zero-width matches\r\n        if (m.index === regex.lastIndex) {\r\n          regex.lastIndex++;\r\n        }\r\n\r\n        if (m.length > 1) {\r\n          errors.push(m[1]);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  return errors;\r\n};\r\n\r\nexport enum SequenceType {\r\n  Sequential,\r\n  Parallel,\r\n  StopOnFailure,\r\n}\r\n\r\nexport async function sendTransactionsWithManualRetry(\r\n  connection: Connection,\r\n  wallet: any,\r\n  instructions: TransactionInstruction[][],\r\n  signers: Keypair[][]\r\n): Promise<(string | undefined)[]> {\r\n  let stopPoint = 0;\r\n  let tries = 0;\r\n  let lastInstructionsLength = null;\r\n  const toRemoveSigners: Record<number, boolean> = {};\r\n  instructions = instructions.filter((instr, i) => {\r\n    if (instr.length > 0) {\r\n      return true;\r\n    } else {\r\n      toRemoveSigners[i] = true;\r\n      return false;\r\n    }\r\n  });\r\n  let ids: string[] = [];\r\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\r\n\r\n  while (stopPoint < instructions.length && tries < 3) {\r\n    instructions = instructions.slice(stopPoint, instructions.length);\r\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\r\n\r\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\r\n    else tries = 0;\r\n\r\n    try {\r\n      if (instructions.length === 1) {\r\n        const id = await sendTransactionWithRetry(\r\n          connection,\r\n          wallet,\r\n          instructions[0],\r\n          filteredSigners[0],\r\n          \"single\"\r\n        );\r\n        ids.push(id.txid);\r\n        stopPoint = 1;\r\n      } else {\r\n        const { txs } = await sendTransactions(\r\n          connection,\r\n          wallet,\r\n          instructions,\r\n          filteredSigners,\r\n          SequenceType.StopOnFailure,\r\n          \"single\"\r\n        );\r\n        ids = ids.concat(txs.map((t) => t.txid));\r\n      }\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n    console.log(\r\n      \"Died on \",\r\n      stopPoint,\r\n      \"retrying from instruction\",\r\n      instructions[stopPoint],\r\n      \"instructions length is\",\r\n      instructions.length\r\n    );\r\n    lastInstructionsLength = instructions.length;\r\n  }\r\n\r\n  return ids;\r\n}\r\n\r\nexport const sendTransactions = async (\r\n  connection: Connection,\r\n  wallet: any,\r\n  instructionSet: TransactionInstruction[][],\r\n  signersSet: Keypair[][],\r\n  sequenceType: SequenceType = SequenceType.Parallel,\r\n  commitment: Commitment = \"singleGossip\",\r\n  successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\r\n  failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\r\n  block?: BlockhashAndFeeCalculator,\r\n  beforeTransactions: Transaction[] = [],\r\n  afterTransactions: Transaction[] = []\r\n): Promise<{ number: number; txs: { txid: string; slot: number }[] }> => {\r\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\r\n\r\n  const unsignedTxns: Transaction[] = beforeTransactions;\r\n\r\n  if (!block) {\r\n    block = await connection.getRecentBlockhash(commitment);\r\n  }\r\n\r\n  for (let i = 0; i < instructionSet.length; i++) {\r\n    const instructions = instructionSet[i];\r\n    const signers = signersSet[i];\r\n\r\n    if (instructions.length === 0) {\r\n      continue;\r\n    }\r\n\r\n    const transaction = new Transaction();\r\n    instructions.forEach((instruction) => transaction.add(instruction));\r\n    transaction.recentBlockhash = block.blockhash;\r\n    transaction.setSigners(\r\n      // fee payed by the wallet owner\r\n      wallet.publicKey,\r\n      ...signers.map((s) => s.publicKey)\r\n    );\r\n\r\n    if (signers.length > 0) {\r\n      transaction.partialSign(...signers);\r\n    }\r\n\r\n    unsignedTxns.push(transaction);\r\n  }\r\n  unsignedTxns.push(...afterTransactions);\r\n\r\n  const partiallySignedTransactions = unsignedTxns.filter((t) =>\r\n    t.signatures.find((sig) => sig.publicKey.equals(wallet.publicKey))\r\n  );\r\n  const fullySignedTransactions = unsignedTxns.filter(\r\n    (t) => !t.signatures.find((sig) => sig.publicKey.equals(wallet.publicKey))\r\n  );\r\n  let signedTxns = await wallet.signAllTransactions(\r\n    partiallySignedTransactions\r\n  );\r\n  signedTxns = fullySignedTransactions.concat(signedTxns);\r\n  const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\r\n\r\n  console.log(\r\n    \"Signed txns length\",\r\n    signedTxns.length,\r\n    \"vs handed in length\",\r\n    instructionSet.length\r\n  );\r\n  for (let i = 0; i < signedTxns.length; i++) {\r\n    const signedTxnPromise = sendSignedTransaction({\r\n      connection,\r\n      signedTransaction: signedTxns[i],\r\n    });\r\n\r\n    if (sequenceType !== SequenceType.Parallel) {\r\n      try {\r\n        await signedTxnPromise.then(({ txid, slot }) =>\r\n          successCallback(txid, i)\r\n        );\r\n        pendingTxns.push(signedTxnPromise);\r\n      } catch (e) {\r\n        console.log(\"Failed at txn index:\", i);\r\n        console.log(\"Caught failure:\", e);\r\n\r\n        failCallback(signedTxns[i], i);\r\n        if (sequenceType === SequenceType.StopOnFailure) {\r\n          return {\r\n            number: i,\r\n            txs: await Promise.all(pendingTxns),\r\n          };\r\n        }\r\n      }\r\n    } else {\r\n      pendingTxns.push(signedTxnPromise);\r\n    }\r\n  }\r\n\r\n  if (sequenceType !== SequenceType.Parallel) {\r\n    const result = await Promise.all(pendingTxns);\r\n    return { number: signedTxns.length, txs: result };\r\n  }\r\n\r\n  return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\r\n};\r\n\r\nexport const sendTransaction = async (\r\n  connection: Connection,\r\n  wallet: any,\r\n  instructions: TransactionInstruction[] | Transaction,\r\n  signers: Keypair[],\r\n  awaitConfirmation = true,\r\n  commitment: Commitment = \"singleGossip\",\r\n  includesFeePayer: boolean = false,\r\n  block?: BlockhashAndFeeCalculator\r\n) => {\r\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\r\n\r\n  let transaction: Transaction;\r\n  if (!Array.isArray(instructions)) {\r\n    transaction = instructions;\r\n  } else {\r\n    transaction = new Transaction();\r\n    instructions.forEach((instruction) => transaction.add(instruction));\r\n    transaction.recentBlockhash = (\r\n      block || (await connection.getRecentBlockhash(commitment))\r\n    ).blockhash;\r\n\r\n    if (includesFeePayer) {\r\n      transaction.setSigners(...signers.map((s) => s.publicKey));\r\n    } else {\r\n      transaction.setSigners(\r\n        // fee payed by the wallet owner\r\n        wallet.publicKey,\r\n        ...signers.map((s) => s.publicKey)\r\n      );\r\n    }\r\n\r\n    if (signers.length > 0) {\r\n      transaction.partialSign(...signers);\r\n    }\r\n    if (!includesFeePayer) {\r\n      transaction = await wallet.signTransaction(transaction);\r\n    }\r\n  }\r\n\r\n  const rawTransaction = transaction.serialize();\r\n  const options = {\r\n    skipPreflight: true,\r\n    commitment,\r\n  };\r\n\r\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\r\n  let slot = 0;\r\n\r\n  if (awaitConfirmation) {\r\n    const confirmation = await awaitTransactionSignatureConfirmation(\r\n      txid,\r\n      DEFAULT_TIMEOUT,\r\n      connection,\r\n      commitment\r\n    );\r\n\r\n    if (!confirmation)\r\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\r\n    slot = confirmation?.slot || 0;\r\n\r\n    if (confirmation?.err) {\r\n      const errors = await getErrorForTransaction(connection, txid);\r\n\r\n      console.log(errors);\r\n      throw new Error(`Raw transaction ${txid} failed`);\r\n    }\r\n  }\r\n\r\n  return { txid, slot };\r\n};\r\n\r\nexport const sendTransactionWithRetry = async (\r\n  connection: Connection,\r\n  wallet: any,\r\n  instructions: TransactionInstruction[],\r\n  signers: Keypair[],\r\n  commitment: Commitment = \"singleGossip\",\r\n  includesFeePayer: boolean = false,\r\n  block?: BlockhashAndFeeCalculator,\r\n  beforeSend?: () => void\r\n) => {\r\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\r\n\r\n  let transaction = new Transaction();\r\n  instructions.forEach((instruction) => transaction.add(instruction));\r\n  transaction.recentBlockhash = (\r\n    block || (await connection.getRecentBlockhash(commitment))\r\n  ).blockhash;\r\n\r\n  if (includesFeePayer) {\r\n    transaction.setSigners(...signers.map((s) => s.publicKey));\r\n  } else {\r\n    transaction.setSigners(\r\n      // fee payed by the wallet owner\r\n      wallet.publicKey,\r\n      ...signers.map((s) => s.publicKey)\r\n    );\r\n  }\r\n\r\n  if (signers.length > 0) {\r\n    transaction.partialSign(...signers);\r\n  }\r\n  if (!includesFeePayer) {\r\n    transaction = await wallet.signTransaction(transaction);\r\n  }\r\n\r\n  if (beforeSend) {\r\n    beforeSend();\r\n  }\r\n\r\n  const { txid, slot } = await sendSignedTransaction({\r\n    connection,\r\n    signedTransaction: transaction,\r\n  });\r\n\r\n  return { txid, slot };\r\n};\r\n\r\nexport const getUnixTs = () => {\r\n  return new Date().getTime() / 1000;\r\n};\r\n\r\nexport async function sendSignedTransaction({\r\n  signedTransaction,\r\n  connection,\r\n  timeout = DEFAULT_TIMEOUT,\r\n}: {\r\n  signedTransaction: Transaction;\r\n  connection: Connection;\r\n  sendingMessage?: string;\r\n  sentMessage?: string;\r\n  successMessage?: string;\r\n  timeout?: number;\r\n}): Promise<{ txid: string; slot: number }> {\r\n  const rawTransaction = signedTransaction.serialize();\r\n\r\n  const startTime = getUnixTs();\r\n  let slot = 0;\r\n  const txid: TransactionSignature = await connection.sendRawTransaction(\r\n    rawTransaction,\r\n    {\r\n      skipPreflight: true,\r\n    }\r\n  );\r\n\r\n  console.log(\"Started awaiting confirmation for\", txid);\r\n\r\n  let done = false;\r\n  (async () => {\r\n    while (!done && getUnixTs() - startTime < timeout) {\r\n      connection.sendRawTransaction(rawTransaction, {\r\n        skipPreflight: true,\r\n      });\r\n      await sleep(500);\r\n    }\r\n  })();\r\n  try {\r\n    const confirmation = await awaitTransactionSignatureConfirmation(\r\n      txid,\r\n      timeout,\r\n      connection,\r\n      \"recent\",\r\n      true\r\n    );\r\n\r\n    if (!confirmation)\r\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\r\n\r\n    if (confirmation.err) {\r\n      console.error(confirmation.err);\r\n      throw new Error(\"Transaction failed: Custom instruction error\");\r\n    }\r\n\r\n    slot = confirmation?.slot || 0;\r\n  } catch (err: any) {\r\n    console.error(\"Timeout Error caught\", err);\r\n    if (err.timeout) {\r\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\r\n    }\r\n    let simulateResult: SimulatedTransactionResponse | null = null;\r\n    try {\r\n      simulateResult = (\r\n        await simulateTransaction(connection, signedTransaction, \"single\")\r\n      ).value;\r\n    } catch (e) {}\r\n    if (simulateResult && simulateResult.err) {\r\n      if (simulateResult.logs) {\r\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\r\n          const line = simulateResult.logs[i];\r\n          if (line.startsWith(\"Program log: \")) {\r\n            throw new Error(\r\n              \"Transaction failed: \" + line.slice(\"Program log: \".length)\r\n            );\r\n          }\r\n        }\r\n      }\r\n      throw new Error(JSON.stringify(simulateResult.err));\r\n    }\r\n    // throw new Error('Transaction failed');\r\n  } finally {\r\n    done = true;\r\n  }\r\n\r\n  console.log(\"Latency\", txid, getUnixTs() - startTime);\r\n  return { txid, slot };\r\n}\r\n\r\nasync function simulateTransaction(\r\n  connection: Connection,\r\n  transaction: Transaction,\r\n  commitment: Commitment\r\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\r\n  // @ts-ignore\r\n  transaction.recentBlockhash = await connection._recentBlockhash(\r\n    // @ts-ignore\r\n    connection._disableBlockhashCaching\r\n  );\r\n\r\n  const signData = transaction.serializeMessage();\r\n  // @ts-ignore\r\n  const wireTransaction = transaction._serialize(signData);\r\n  const encodedTransaction = wireTransaction.toString(\"base64\");\r\n  const config: any = { encoding: \"base64\", commitment };\r\n  const args = [encodedTransaction, config];\r\n\r\n  // @ts-ignore\r\n  const res = await connection._rpcRequest(\"simulateTransaction\", args);\r\n  if (res.error) {\r\n    throw new Error(\"failed to simulate transaction: \" + res.error.message);\r\n  }\r\n  return res.result;\r\n}\r\n\r\nasync function awaitTransactionSignatureConfirmation(\r\n  txid: TransactionSignature,\r\n  timeout: number,\r\n  connection: Connection,\r\n  commitment: Commitment = \"recent\",\r\n  queryStatus = false\r\n): Promise<SignatureStatus | null | void> {\r\n  let done = false;\r\n  let status: SignatureStatus | null | void = {\r\n    slot: 0,\r\n    confirmations: 0,\r\n    err: null,\r\n  };\r\n  let subId = 0;\r\n  status = await new Promise(async (resolve, reject) => {\r\n    setTimeout(() => {\r\n      if (done) {\r\n        return;\r\n      }\r\n      done = true;\r\n      console.log(\"Rejecting for timeout...\");\r\n      reject({ timeout: true });\r\n    }, timeout);\r\n    try {\r\n      subId = connection.onSignature(\r\n        txid,\r\n        (result, context) => {\r\n          done = true;\r\n          status = {\r\n            err: result.err,\r\n            slot: context.slot,\r\n            confirmations: 0,\r\n          };\r\n          if (result.err) {\r\n            console.log(\"Rejected via websocket\", result.err);\r\n            reject(status);\r\n          } else {\r\n            console.log(\"Resolved via websocket\", result);\r\n            resolve(status);\r\n          }\r\n        },\r\n        commitment\r\n      );\r\n    } catch (e) {\r\n      done = true;\r\n      console.error(\"WS error in setup\", txid, e);\r\n    }\r\n    while (!done && queryStatus) {\r\n      // eslint-disable-next-line no-loop-func\r\n      (async () => {\r\n        try {\r\n          const signatureStatuses = await connection.getSignatureStatuses([\r\n            txid,\r\n          ]);\r\n          status = signatureStatuses && signatureStatuses.value[0];\r\n          if (!done) {\r\n            if (!status) {\r\n              console.log(\"REST null result for\", txid, status);\r\n            } else if (status.err) {\r\n              console.log(\"REST error for\", txid, status);\r\n              done = true;\r\n              reject(status.err);\r\n            } else if (!status.confirmations) {\r\n              console.log(\"REST no confirmations for\", txid, status);\r\n            } else {\r\n              console.log(\"REST confirmation for\", txid, status);\r\n              done = true;\r\n              resolve(status);\r\n            }\r\n          }\r\n        } catch (e) {\r\n          if (!done) {\r\n            console.log(\"REST connection error: txid\", txid, e);\r\n          }\r\n        }\r\n      })();\r\n      await sleep(2000);\r\n    }\r\n  });\r\n\r\n  //@ts-ignore\r\n  try {\r\n    await connection.removeSignatureListener(subId);\r\n  } catch (e) {\r\n    // ignore\r\n  }\r\n  done = true;\r\n  console.log(\"Returning status\", status);\r\n  return status;\r\n}\r\nexport function sleep(ms: number): Promise<void> {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}